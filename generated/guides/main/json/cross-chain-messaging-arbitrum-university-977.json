{
  "categories": [],
  "content": "Bridging Blockchains with Seamless Communication",
  "created": "2023-12-04T11:29:53.125Z",
  "guideType": "onboarding",
  "key": "cross-chain-messaging-arbitrum-university-977",
  "name": "Cross Chain Messaging",
  "publishStatus": "Live",
  "steps": [
    {
      "content": "## What is Cross Chain Messaging?\nCross-chain messaging is the process of transferring data, tokens, and other types of assets between different blockchain networks. Blockchains traditionally operate in silos, meaning they function independently and cannot natively share information or assets with one another. Cross-chain technology aims to bridge this gap, allowing for interoperability, or the ability for diverse blockchain networks to communicate and interact seamlessly.\n\nCross-chain messaging works through smart contracts that facilitate the free flow of information between isolated blockchain networks. This creates a decentralized network where users can interact with dApps across different chains in a verifiable and trustless manner, supported by on-chain validators, without the need for manual navigation through bridges. This interconnectedness promises a streamlined and decentralized Web3 ecosystem, enhancing user experience and enabling developers to offer more integrated and efficient dApp services.\n\n## Need for Cross Chain Messaging\nCross-chain messaging is essential for addressing several needs in the cryptocurrency sector:\n\n1. **Asset Interoperability**: It allows for the seamless transfer of assets between different blockchains, helping to reduce the fragmentation of capital. By enabling this flow, smaller blockchains can access the liquidity and user base of larger ones, increasing overall capital efficiency and improving liquidity conditions.\n\n2. **Decentralization**: Cross-chain technology supports the decentralized movement of funds, reducing reliance on centralized entities or custodians. This trustless nature of technology is a core principle of blockchain interoperability, promoting a more decentralized financial ecosystem.\n\n3. **Minimizing Fragmentation and Improving Composability**: As the blockchain space grows, a smart contract's ability to interact natively is limited to its home network. Cross-chain messaging opens up the possibility for these contracts to interact beyond their native chains, thus reducing the issues of fragmented liquidity and improving the composability of applications across the broader blockchain landscape.\n\n4. **Efficient Resource Utilization**: Deploying applications on multiple chains consumes significant development resources. Cross-chain messaging aims to streamline this process, enabling applications to interact across chains without the need for separate deployments, which allows developers to focus on improving the core functionality of their applications. ",
      "name": "Cross Chain Messaging",
      "stepItems": [],
      "uuid": "2b2cd485-6d77-4bb6-ab60-a13ab658feb0"
    },
    {
      "content": "",
      "name": "Evaluation",
      "stepItems": [],
      "uuid": "0b537aa5-d7f1-41bf-88e1-f0b38af513dc"
    },
    {
      "content": "The Arbitrum protocol and its associated tools simplify the process for developers to create cross-chain applications, enabling them to efficiently send messages between Ethereum and an Arbitrum chain, as well as in the reverse direction from an Arbitrum chain back to Ethereum.\n\n### Ethereum to Arbitrum Messaging \nContract calls from Ethereum's Layer 1 to Arbitrum's Layer 2 can be initiated using the `createRetryableTicket` method of the Inbox contract. When the transaction is executed on Layer 1, the corresponding action on Layer 2 is usually processed within a short time frame. Typically, the execution on Layer 2 completes successfully; however, in cases where it does not and a reversal occurs, it can be attempted again by invoking the `redeem` function of the ArbRetryableTx precompiled contract.\n\nTo visualise the example, check out the tutorial at https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/greeter.\n\n### Arbitrum to Ethereum Messaging \nContracts on Arbitrum's Layer 2 can also send messages to be executed on Ethereum's Layer 1. This is done by invoking the `sendTxToL1` function on the ArbSys precompiled contract. After a waiting period for confirmation, which typically lasts about one week, these messages can be processed. The necessary data for execution is obtained by calling the `constructOutboxProof` method of the NodeInterface contract. Following this, the messages are executed on Layer 1 through the Outbox contract's `executeTransaction` method.\n\nTo better understand, check out the demo at https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/outbox-execute.",
      "name": "Arbitrum's Cross Chain Messaging",
      "stepItems": [],
      "uuid": "c6565013-2272-47a3-9ff0-d6aa141f938f"
    },
    {
      "content": "",
      "name": "Evaluation",
      "stepItems": [],
      "uuid": "1682ade3-97a3-4d83-bdfb-e75758c2edf4"
    },
    {
      "content": "## What are Retryable Tickets?\nRetryable tickets in the Arbitrum system are a specific mechanism designed for sending messages from Ethereum's Layer 1 (L1) to Arbitrum's Layer 2 (L2). They allow for the initiation of L1 transactions that will trigger executions on L2. When you submit a retryable ticket, you pay a fixed fee based on the size of the transaction data at L1. This fee ensures that the message is transmitted to L2, where it will be executed separately from the L1 transaction and at a different time, making the process asynchronous.\n\nThe key feature of retryable tickets is that they ensure atomicity across the L1 and L2 operations. Atomicity means that the operations are linked; if the initial transaction on L1 that requests the submission is successful and does not revert, there is a strong assurance that the associated message will be executed on L2 eventually. This creates a reliable link between the two layers, allowing developers and users to coordinate complex cross-chain interactions with confidence that the actions will be completed as intended.\n\n## Lifecycle of Retryable Tickets \nThe lifecycle of retryable tickets consists of the following 3 stages:\n\n### 1. Submission \nA retryable ticket is created by calling the `createRetryableTicket` function in the inbox contract. If this call is successful, a ticket will definitely be issued. It requires the sender to allocate enough funds for both submission and an execution attempt, yet this does not ensure the ticket's automatic redemption will succeed. When the correct funds are submitted, a new ticket with a unique ID is created and added to retryable buffer. The sender's account is charged for funds (submissionCost + I2CallValue), which is then reserved in escrow to use when the ticket is activated. Ticket creation causes the `ArbRetryableTx` precompile to emit a `TicketCreated` event containing the `TicketID` on L2.\n- `l1CallValue (also referred to as deposit)`: Not a real function parameter, it is rather the callValue that is sent along with the transaction\n- `address to`: The destination L2 address\n- `uint256 l2CallValue`: The callvalue for retryable L2 message that is supplied within the deposit (l1CallValue)\n- `uint256 maxSubmissionCost`: The maximum amount of ETH to be paid for submitting the ticket. This amount is (1) supplied within the deposit (l1CallValue) to be later deducted from sender's L2 balance and is (2) directly proportional to the size of the retryable’s data and L1 basefee\n- `address excessFeeRefundAddress`: The L2 address to which the excess fee is credited (l1CallValue - (autoredeem ? ticket execution cost : submission cost) - l2CallValue)\n- `address callValueRefundAddress`: The L2 address to which the l2CallValue is credited if the ticket times out or gets cancelled (this is also called the `beneficiary`, who's got a critical permission to cancel the ticket)\n- `uint256 gasLimit`: Maximum amount of gas used to cover L2 execution of the ticket\n- `uint256 maxFeePerGas`: The gas price bid for L2 execution of the ticket that is supplied within the deposit (l1CallValue)\n- `bytes calldata data`: The calldata to the destination L2 address\n\n<div align=\"center\">\n  <img style=\"max-height:400px;margin-bottom:30px\" src=\"https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/cross_chain_messaging_arbitrum_university_977/1699898912101_screenshot_2023-11-13%20at%2011.07.31%20pm.png\"/>\n</div>\n\n### 2. Automatic Redemption \nTicket submission on Layer 1 and execution on Layer 2 are separate events; successful submission doesn't ensure execution. For execution, the user must have enough funds to cover the transaction fee and the base fee on Layer 2. If these criteria are met, the ticket will automatically attempt to execute, with success or failure depending on the gas provided. If the ticket auto-redeems successfully, it carries out the transaction with the original details including the sender, destination, callvalue and calldata from the submission. Any excess submission fee is returned to the user on Layer 2. To improve the chances of successful auto-redeem, the Arbitrum SDK can be used to determine the correct gas parameters for Layer 1 to Layer 2 messages. If the ticket isn't redeemed at submission or the first redeem attempt fails (possibly due to a rise in the Layer 2 gas price), the submission fee is used to store the ticket in memory for a week. Under these circumstances, the ticket must be redeemed manually.\n\n<div align=\"center\">\n  <img style=\"max-height:400px;margin-bottom:30px\" src=\"https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/cross_chain_messaging_arbitrum_university_977/1699899673388_screenshot_2023-11-13%20at%2011.20.35%20pm.png\"/>\n</div>\n\n### 3. Manual Redemption\nAnyone can try to manually redeem an unclaimed ticket by using the ArbRetryableTx's redeem function, which supplies the gas for the redemption without being restricted by the original gas limit. ArbOS will prioritize this redemption in its processing queue, ensuring it's executed in the same block as the calling transaction, with no risk of hitting the block's gas limit before execution. If the fixed period (one week) elapses without a successful redeem, the ticket expires and will be automatically discarded, unless some party has paid a fee to keep the ticket alive for another full period. A ticket can live indefinitely as long as it is renewed each time before it expires. Upon successful redemption, the designated recipient gets the escrowed funds, and any leftover gas goes back to the system's gas pools. If it fails, the funds return to escrow for another try. Fees are settled during the initial transaction, so no additional fees are incurred or refunded at this stage. It's also important to note that while a ticket redemption is in progress, any attempts to cancel or reschedule it will fail, ensuring the ticket doesn't change during this process. If a ticket with funds is ultimately not used (either cancelled or expired), the escrowed funds will be sent to a specified refund address from the original submission.\n\n<div align=\"center\">\n  <img style=\"max-height:400px;margin-bottom:30px\" src=\"https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/cross_chain_messaging_arbitrum_university_977/1699900133766_screenshot_2023-11-13%20at%2011.28.17%20pm.png\"/>\n</div>\n\n",
      "name": "L1 to L2 Messaging",
      "stepItems": [],
      "uuid": "4c6d4203-d72d-45fc-bdbd-c0d8b9dc899d"
    },
    {
      "content": "",
      "name": "Evaluation",
      "stepItems": [],
      "uuid": "45ccd21e-4685-41e2-b6f7-18d3c9f606fd"
    },
    {
      "content": "## Receipt \nThe life of a retryable ticket generates two types of Layer 2 receipts:\n\n**1. Ticket Creation Receipt:** Emitted when a ticket is created successfully via the Inbox's createRetryableTicket method. It includes a TicketCreated event with a ticketId, which can be calculated using RLP encoding and hashing.\n\n**2. Redeem Attempt Receipt:** Emitted after a ticket is tried for execution on Layer 2, indicating whether the redeem was successful or failed. It includes a RedeemScheduled event with a ticketId. There will be only one successful redeem receipt per ticket—if the initial auto-redeem is successful, no other receipts are issued for that ticket. If the auto-redeem fails or isn't attempted, subsequent attempts will continue to emit redeem receipts until one is successful.\n\n## Alternative \"unsafe\" Retryable Ticket Creation\nThe `Inbox.createRetryableTicket` method has built-in checks to ensure that users provide enough funds from Layer 1 to cover the costs of creating a ticket. It also handles the conversion of `callValueRefundAddress` and `excessFeeRefundAddress` to their respective address aliases if they are identified as contracts, which is determined during the call. This provides a way for contracts on Layer 1 to reclaim funds. However, for those with advanced knowledge, there is an alternative method, `Inbox.unsafeCreateRetryableTicket`, which omits these safety checks and is only recommended for experts.\n\n## Eth deposits\nThere's a specific way to transfer Eth from Layer 1 (L1) to Layer 2 (L2) by using the Inbox's `depositEth` method. When someone sends Eth this way, it will be credited to their same address on L2 if they're an externally owned account (EOA). If a contract makes the deposit, the Eth goes to a corresponding special address for the contract on L2. It's important to note that using `depositEth` to send Eth directly to a contract on L2 doesn't activate the contract's fallback function. While direct deposits are straightforward, retryable tickets offer a more flexible alternative for sending Ether to L2. They can specify different destination addresses or activate a contract's fallback function on L2, which the standard eth-deposit method does not.\n\n## Transacting via the Delayed Inbox\nAlthough the submission of retryable tickets and Eth deposits is required to go through the delayed inbox, in theory, it's possible to send any type of message this way. This approach is crucial for maintaining the Arbitrum chain's ability to resist censorship, particularly if there are issues with the Sequencer not acting as it should. Nonetheless, during regular operations, it's advised that clients limit their use of the delayed inbox to just retryable tickets and Eth deposits, while utilizing the Sequencer for sending all other types of messages.\n\n## Address Aliasing\nMessages sent through the Delayed Inbox have their sender's address transformed into a version known as the \"L2 Alias\" when executed on Layer 2. This means the address that appears as `msg.sender` in the execution context is not the original Layer 1 address, but rather this altered \"L2 Alias.\" Specifically, the L2 Alias is created by adding the hexadecimal value `0x1111000000000000000000000000000000001111` to the original address. For example:\n\n`L2_Alias = L1_Contract_Address + 0x1111000000000000000000000000000000001111`\n\nThe Arbitrum protocol assigns L2 Aliases to messages moving from L1 to L2 to avoid potential security issues that could arise if L1 addresses were used directly on L2. For example, without L2 Aliases, an attacker might deceive an L2 contract by sending a message from a contract address on L1 that the L2 contract is designed to trust. To counteract such cross-chain threats, L2 Aliases differentiate the sender's identity on L2.\nIf there's ever a need to determine the original L1 address from its L2 alias while on the chain, the AddressAliasHelper library provided by Arbitrum can be used for this purpose:\n\n`modifier onlyFromMyL1Contract() override {\n    require(AddressAliasHelper.undoL1ToL2Alias(msg.sender) == myL1ContractAddress, \"ONLY_COUNTERPART_CONTRACT\");\n    _;\n}`",
      "name": "Additional Concepts",
      "stepItems": [],
      "uuid": "47dca17b-42d8-43ff-a8ae-894f128e993e"
    },
    {
      "content": "",
      "name": "Evaluation",
      "stepItems": [],
      "uuid": "895f2692-d815-4d2a-9fec-59ae56ce5179"
    },
    {
      "content": "Arbitrum's Outbox allows contracts on Layer 2 (L2) to send messages that result in actions on Layer 1 (L1). These outgoing messages are similar to the process for sending messages from L1 to L2, but in the opposite direction and with some variations.\n\n## Working of Protocol \nArbitrum keeps track of messages sent from Layer 2 (L2) to Layer 1 (L1) by using a system similar to a digital fingerprint called a Merkle root. This fingerprint is included in every RBlock, a type of data block in Arbitrum, and after about a week, the RBlock gets confirmed and the fingerprint is recorded on Layer 1 in something called the Outbox contract. This Outbox contract then checks the messages' fingerprints to make sure they're valid and keeps track of which messages have been processed.\n\n### Steps for Users\nFor users, sending a message from Layer 2 (L2) to Layer 1 (L1) starts with a command to the L2 ArbSys contract. The message gets included in a kind of data packet called an assertion usually within about an hour, and after around a week, this assertion is officially confirmed. Once that's done, anyone can activate the message. They do this by getting special proof from the Arbitrum system, then using that proof with the Outbox's function to make the message do its job on Layer 1.\n\n## Protocol Design Details \nThe L2 to L1 is specially designed to efficiently process transactions across the two layers. It consists of the following features:\n\n### Controlled Transaction Processing Effort\nThe Outbox system in Arbitrum is designed so that the step where data blocks (RBlocks) are confirmed will always take the same amount of effort, no matter how many messages it's processing. This is because the system only updates a small piece of data (the outgoing message root hash) during confirmation, and users themselves handle the actual execution of messages. This design prevents the confirmation process from being deliberately slowed down or \"griefed.\"\n\n### Outgoing Messages Different From Retryable tickets\nOutgoing messages, unlike retryable tickets which can include Ether for automatic execution on L2, don't have a built-in way to automatically execute on L1. That's because Ethereum doesn't have a feature for scheduling automatic actions. However, special contracts could be created to manage this execution step on L1. Outgoing messages also differ from retryable tickets in their lifespan. Retryable tickets expire unless they're redeemed or extended, while outgoing messages are recorded on L1 and last indefinitely without a deadline for execution.\n\n### Week Long Waiting Period\nThe delay of about a week before outgoing messages can be executed is a built-in part of how Arbitrum's system works. This waiting period allows time for validators to challenge the results if there are any issues. For those interested in the technical side, Arbitrum has a feature called NodeInterface, which acts like a built-in contract to provide specific data for Arbitrum without needing to be an actual contract on the blockchain.",
      "name": "L2 to L1 Messaging",
      "stepItems": [],
      "uuid": "9e939755-5c98-45a0-8335-cdd8adb16734"
    },
    {
      "content": "",
      "name": "Evaluation",
      "stepItems": [],
      "uuid": "a8ed5c86-cc78-469c-ab98-aac3701cf5d5"
    },
    {
      "content": "## Step 1\n\n- https://www.techopedia.com/definition/cross-chain-in-blockchain#:~:text=XCM%20is%20a%20messaging%20format,chain%20and%20executed%20in%20another.\n- https://chain.link/education/cross-chain\n\n",
      "name": "References",
      "stepItems": [],
      "uuid": "c77989b0-22f7-4926-8e33-9b38540f66e8"
    }
  ],
  "thumbnail": "https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/cross_chain_messaging_arbitrum_university_977/1699877869240_rectangle_101.png",
  "uuid": "cross-chain-messaging-arbitrum-university-977",
  "version": 1,
  "priority": 50
}