{
  "categories": [],
  "content": "A deeper look into Arbitrum Nitro",
  "created": "2023-12-11T17:18:30.936Z",
  "guideType": "onboarding",
  "key": "arbitrum-nitro-arbitrum-university-560",
  "name": "Arbitrum Nitro ",
  "publishStatus": "Live",
  "steps": [
    {
      "content": "## What is Arbitrum Nitro?\n\nArbitrum Nitro is a significant technical upgrade for Arbitrum, which is a Layer 2 scaling solution for Ethereum. It aims to lower transaction fees and increase the processing capacity of Ethereum by moving contract computation and storage from the primary chain. This upgrade, known as Nitro, is designed to be more compatible with the Ethereum Virtual Machine (EVM) and provides a better user experience with lower fees and faster transactions. With Nitro, Arbitrum aims to push the boundaries of security, efficiency, and scalability, offering a promising solution for the future of Ethereum. \n\n<div align=\"center\">\n  <img style=\"max-height:600px;margin-bottom:40px\" src=\"https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/arbitrum_nitro_arbitrum_university_560/1700677384029_nitro.png\"/>\n</div>\n\nIt introduces advanced calldata compression, reducing transaction costs even further. Nitro enhances the performance of Layer 1 (L1) nodes, aligns EVM operation pricing with Ethereum, and introduces additional synchronization with Ethereum L1 blocks. As it seamlessly supports the Ethereum Virtual Machine (EVM), no hefty modifications are required. With Nitro, transactions on Arbitrum have become extremely efficient. \n\n## Innovative Features of Arbitrum Nitro\n\n#### WebAssembly Code\n\nNitro introduces a new prover that uses WebAssembly (WASM) code to perform Arbitrum's interactive fraud proofs. This upgrade enhances the scalability and efficiency of the system, allowing for thousands of transactions to be processed per second. Despite being a separate blockchain, Arbitrum Nitro maintains the security and privacy features of Ethereum's Layer 1 (L1) and relays all transaction information to the main Ethereum chain.\n\n<div align=\"center\">\n  <img style=\"max-height:600px;margin-bottom:40px\" src=\"https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/arbitrum_nitro_arbitrum_university_560/1700677415896_features.png\"/>\n</div>\n\n#### EVM Compatiblility\n\nDevelopers can easily integrate Arbitrum Nitro without making any modifications because it supports the EVM. This means that existing Ethereum contracts and transactions can run on Arbitrum without any changes. This distinguishes Arbitrum Nitro from other layer 2 solutions as each have their own VMs thereby requiring modifications for integration. \n\n#### Deterministic Transactions\n\nTo use Arbitrum Nitro, users need to submit their transactions to the chain's inbox. The chain will then execute the transaction and produce outputs, including a transaction receipt and any initiated withdrawals. The execution of transactions is deterministic, meaning that the result is known as soon as the transaction is placed in the inbox. Arbitrum ensures the correctness of the chain state and outputs, supports Ethereum-compatible contracts and transactions, and manages the transfer and management of ETH and tokens on the chain. ",
      "name": "Introduction to Arbitrum Nitro",
      "stepItems": [],
      "uuid": "71f23120-3f81-446c-9d03-fe061903a797"
    },
    {
      "content": "",
      "name": "Evaluation",
      "stepItems": [
        {
          "answerKeys": [
            "C"
          ],
          "choices": [
            {
              "content": "To increase transaction fees on Ethereum",
              "key": "A"
            },
            {
              "content": "To decrease the processing capacity of Ethereum",
              "key": "B"
            },
            {
              "content": "To lower transaction fees and increase the processing capacity of Ethereum",
              "key": "C"
            },
            {
              "content": "To move contract computation and storage to the primary chain",
              "key": "D"
            }
          ],
          "content": "What is the main purpose of Arbitrum Nitro?",
          "type": "SingleChoice",
          "uuid": "48a2c68f-2555-4e98-92ef-036cf7a12079",
          "explanation": "Arbitrum Nitro is a significant technical upgrade for Arbitrum, a Layer 2 scaling solution for Ethereum. It aims to lower transaction fees and increase the processing capacity of Ethereum by moving contract computation and storage from the primary chain."
        },
        {
          "answerKeys": [
            "B"
          ],
          "choices": [
            {
              "content": "It requires developers to make modifications to integrate it",
              "key": "A"
            },
            {
              "content": "Existing Ethereum contracts and transactions can run on Arbitrum without any changes",
              "key": "B"
            },
            {
              "content": "It is not compatible with other layer 2 solutions",
              "key": "C"
            },
            {
              "content": "It does not support Ethereum contracts and transactions",
              "key": "D"
            }
          ],
          "content": "What is the advantage of Arbitrum Nitro's compatibility with the Ethereum Virtual Machine (EVM)?",
          "type": "SingleChoice",
          "uuid": "db2d69df-8a88-4f47-8f0d-0e9c8587aedc",
          "explanation": "Because Arbitrum Nitro supports the EVM, developers can easily integrate it without making any modifications. This means that existing Ethereum contracts and transactions can run on Arbitrum without any changes."
        },
        {
          "answerKeys": [
            "D"
          ],
          "choices": [
            {
              "content": "Python code",
              "key": "A"
            },
            {
              "content": "Java code",
              "key": "B"
            },
            {
              "content": "C++ code",
              "key": "C"
            },
            {
              "content": "WebAssembly (WASM) code",
              "key": "D"
            }
          ],
          "content": "What does Arbitrum Nitro use to perform Arbitrum's interactive fraud proofs?",
          "type": "SingleChoice",
          "uuid": "c240c761-7968-4893-b7ea-36c994f04a01",
          "explanation": "Nitro introduces a new prover that uses WebAssembly (WASM) code to perform Arbitrum's interactive fraud proofs. This upgrade enhances the scalability and efficiency of the system, allowing for thousands of transactions to be processed per second."
        }
      ],
      "uuid": "40dd8254-e6e1-4dd7-9e68-34f14bf45792"
    },
    {
      "content": "Here is the comparison between Arbitrum Nitro and Arbitrum Classic (original version of Arbitrum):\n\n| Feature                                  | Arbitrum Classic                                              | Arbitrum Nitro                                                  |\n|------------------------------------------|---------------------------------------------------------------|-----------------------------------------------------------------|\n| Goal                                     | Execution environment resembling EVM as second layer to Ethereum | Execution environment resembling EVM as second layer to Ethereum |\n| Virtual Machine Used                     | Arbitrum Virtual Machine (AVM)                                  | WebAssembly (Wasm)                                              |\n| Low-Level Instructions                   | Uses AVM for low-level instructions                             | Compiles Go code to WASM for low-level instructions             |\n| Architecture                             | Relies on AVM for execution environment                         | Direct usage of Geth's EVM implementation, enhancing efficiency |\n| Gas Fees and Ethereum Compatibility      | Higher fees compared to Nitro, due to less optimized execution environment | Lower fees and better Ethereum compatibility due to native execution of Go code |\n| Codebase Simplicity                      | More complex due to custom AVM, posing higher technical risks   | Simpler and more accessible codebase, reducing technical risks  |\n| Coding Languages                         | Solidity or Vyper                                                | Go (a more common language)                                     |\n| Code Conversion                          | EVM bytecode converted to AVM bytecode                           | Uses Wasm only when there's a dispute                           |\n| Transaction Management and Fraud Proofs  | AVM bytecode runs transactions and generates fraud proofs        | Checkpoints summarize transactions; Wasm used for disputes      |\n| Dispute Resolution                       | Validators inspect AVM bytecode in case of disputes              | Validators agree on block before examining Wasm details         |\n| Efficiency and Resource Management       | Less efficient, prepares for problems even if they do not occur  | More efficient, converts to Wasm only during disputes, saving time and resources |\n",
      "name": "Nitro vs Classic",
      "stepItems": [],
      "uuid": "488abfeb-0e2c-472d-88cf-8fbc888963ee"
    },
    {
      "content": "",
      "name": "Evaluation",
      "stepItems": [
        {
          "answerKeys": [
            "A"
          ],
          "choices": [
            {
              "content": "Execution environment resembling EVM as second layer to Ethereum",
              "key": "A"
            },
            {
              "content": "To replace Ethereum with a more efficient blockchain",
              "key": "B"
            },
            {
              "content": "To create a new cryptocurrency",
              "key": "C"
            },
            {
              "content": "To compete with Bitcoin",
              "key": "D"
            }
          ],
          "content": "What is the goal of both Arbitrum Classic and Arbitrum Nitro?",
          "type": "SingleChoice",
          "uuid": "1be94b16-85fb-4eac-8f7e-e187dfd355d2",
          "explanation": "The goal of both Arbitrum Classic and Arbitrum Nitro is to provide an execution environment that resembles EVM as a second layer to Ethereum."
        },
        {
          "answerKeys": [
            "B"
          ],
          "choices": [
            {
              "content": "Arbitrum Classic",
              "key": "A"
            },
            {
              "content": "Arbitrum Nitro",
              "key": "B"
            },
            {
              "content": "Both",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ],
          "content": "Which version of Arbitrum uses WebAssembly (Wasm) for low-level instructions?",
          "type": "SingleChoice",
          "uuid": "5d993ba8-3684-4abf-a571-4f0f4d67e00f",
          "explanation": "Arbitrum Nitro uses WebAssembly (Wasm) for low-level instructions, while Arbitrum Classic uses Arbitrum Virtual Machine (AVM)."
        },
        {
          "answerKeys": [
            "B"
          ],
          "choices": [
            {
              "content": "Arbitrum Classic",
              "key": "A"
            },
            {
              "content": "Arbitrum Nitro",
              "key": "B"
            },
            {
              "content": "Both",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ],
          "content": "Which version of Arbitrum came earlier?",
          "type": "SingleChoice",
          "uuid": "21e4433e-adbb-4a83-a113-9eed571d1197",
          "explanation": "Arbitrum Nitro has lower fees and better Ethereum compatibility due to native execution of Go code."
        }
      ],
      "uuid": "ca041520-b639-4eab-b2c7-37b09560b6ea"
    },
    {
      "content": "## How Transactions Work?\n\nDesigned to enhance efficiency and streamline workflows, the Nitro design emerges as an evidence to innovation in the Ethereum ecosystem. The transaction pocess in Arbitrum Nitro technology consists of the following cricial steps:\n\n<div align=\"center\">\n  <img style=\"max-height:600px;margin-bottom:40px\" src=\"https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/arbitrum_nitro_arbitrum_university_560/1700677469815_transaction_lifecycle.png\"/>\n</div>\n\n#### Step 1: Sequencing and Deterministic Execution\n\nWhen a user sends a transaction on the Nitro chain, it is signed with their wallet and given to the Sequencer. The Sequencer orders transactions and publishes them, after which they're processed to update the Nitro chain state, producing Layer 2 blocks as needed. Invalid transactions are rejected to keep the sequence authentic. The Sequencer uses a real-time alert system for immediate soft finality and batches transactions on the Ethereum chain for hard finality. The latter involves compressing transactions using \"brotli\" and posting them to Ethereum, where their finalization ensures the sequence's immutability on Nitro.\n\n#### Step 2: State Transition Function\n\nIn Arbitrum Nitro's transaction lifecycle, the State Transition Function (STF) is crucial for updating the blockchain's state. Once a transaction is submitted, it enters the Nitro system either through a Sequencer or directly into the inbox. The STF then processes these transactions, taking the current state and the transaction data to compute a new state. It performs all the necessary calculations and state alterations in a deterministic manner, such as adjusting account balances and modifying smart contract states. This transition is then reflected on the chain, with the STF ensuring that the state progresses correctly and consistently after each transaction, maintaining the integrity and continuity of the blockchain's ledger.\n\n#### Step 3: Posting on Layer 1\n\nIn Arbitrum Nitro's transaction lifecycle, data posting on Layer 1 is where transaction inputs are recorded as calldata on the Ethereum blockchain, allowing for full transparency and enabling anyone to reconstruct the chain's state. This process supports the network's optimistic rollup approach, where validators post proposed rollup blocks to Layer 1, which are assumed correct unless challenged within a roughly one-week period. If unchallenged, the block is confirmed, but disputed blocks trigger Arbitrum's dispute resolution protocol to determine accuracy, penalizing dishonest validators with deposit forfeiture. This design ensures the integrity of posted data while minimizing fraud.\n\n## Nitro Under the Hood\n\nArbitrum Nitro's innovative architecture is designed to streamline both the execution of smart contracts and the verification process in case of disputes. Central to this architecture is the implementation of \"geth at the core,\" which utilizes go-ethereum, the commonly used Ethereum node software, written in the Go programming language. This foundational approach is manifested in a layered structure. Nitro harnesses the power of this setup to optimise performance while maintaining the robustness of security and verification processes.\n\n### Layers of Nitro Node\n\nNitro utilizes the same source code for two distinct tasks: execution and proving, by employing \"geth at the core.\" The Nitro node software, predominantly written in Go like go-ethereum (geth), consists of three main layers—the base layer with core geth functionalities, the middle layer called ArbOS providing Layer 2 features, and the top layer handling node operations, also derived from geth. This layered design forms the \"geth sandwich,\" with geth as the bread and ArbOS as the filling.\n\n<div align=\"center\">\n  <img style=\"max-height:600px;margin-bottom:40px\" src=\"https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/arbitrum_nitro_arbitrum_university_560/1700677506703_layers.png\"/>\n</div>\n\n### Dual Compilation Strategy\n\nFor execution, the source code is compiled into native code using the standard Go compiler, customized for the specific architecture of the node deployment. In contrast, for proving—particularly important when disputes arise—the same source code, especially the State Transition Function (STF), is compiled to WebAssembly (WASM), a portable machine code format. This WASM code is then transformed into WAVM, a modified version for proof procedures. When a dispute occurs, the verification of the STF's results is conducted with reference to the WAVM code, ensuring that the same logic governs both normal operation and the verification process during disputes.",
      "name": "Arbitrum Nitro Design ",
      "stepItems": [],
      "uuid": "fc866114-3380-41da-a037-351a9246246a"
    },
    {
      "content": "",
      "name": "Evaluation",
      "stepItems": [
        {
          "answerKeys": [
            "C"
          ],
          "choices": [
            {
              "content": "It is responsible for creating new transactions",
              "key": "A"
            },
            {
              "content": "It is responsible for verifying the authenticity of transactions",
              "key": "B"
            },
            {
              "content": "It orders transactions and publishes them",
              "key": "C"
            },
            {
              "content": "It is responsible for dispute resolution",
              "key": "D"
            }
          ],
          "content": "What is the role of the Sequencer in the Arbitrum Nitro's transaction process?",
          "type": "SingleChoice",
          "uuid": "ee4f4b07-9891-46eb-b763-69ef39023747",
          "explanation": "The Sequencer in Arbitrum Nitro's transaction process is responsible for ordering transactions and publishing them. It uses a real-time alert system for immediate soft finality and batches transactions on the Ethereum chain for hard finality."
        },
        {
          "answerKeys": [
            "B"
          ],
          "choices": [
            {
              "content": "It is responsible for creating new transactions",
              "key": "A"
            },
            {
              "content": "It processes transactions and updates the blockchain's state",
              "key": "B"
            },
            {
              "content": "It verifies the authenticity of transactions",
              "key": "C"
            },
            {
              "content": "It is responsible for dispute resolution",
              "key": "D"
            }
          ],
          "content": "What is the function of the State Transition Function (STF) in Arbitrum Nitro's transaction lifecycle?",
          "type": "SingleChoice",
          "uuid": "f4e849f5-549b-4b31-a774-d0ece2a49425",
          "explanation": "In Arbitrum Nitro's transaction lifecycle, the State Transition Function (STF) is crucial for updating the blockchain's state. It processes transactions, taking the current state and the transaction data to compute a new state."
        },
        {
          "answerKeys": [
            "D"
          ],
          "choices": [
            {
              "content": "To create new transactions",
              "key": "A"
            },
            {
              "content": "To verify the authenticity of transactions",
              "key": "B"
            },
            {
              "content": "To order transactions",
              "key": "C"
            },
            {
              "content": "To record transaction inputs as calldata on the Ethereum blockchain",
              "key": "D"
            }
          ],
          "content": "What is the purpose of posting data on Layer 1 in Arbitrum Nitro's transaction lifecycle?",
          "type": "SingleChoice",
          "uuid": "d95b6b72-8ae0-4d96-b4a3-1440c1a374aa",
          "explanation": "In Arbitrum Nitro's transaction lifecycle, data posting on Layer 1 is where transaction inputs are recorded as calldata on the Ethereum blockchain, allowing for full transparency and enabling anyone to reconstruct the chain's state."
        }
      ],
      "uuid": "e49c619f-5960-4060-9b89-cdd09521cf36"
    },
    {
      "content": "- https://docs.arbitrum.io/why-nitro\n\n- https://docs.arbitrum.io/inside-arbitrum-nitro/#:~:text=Nitro%20is%20a%20major%20upgrade,of%20data%20posted%20to%20L1\n\n- https://medium.com/offchainlabs/arbitrum-nitro-one-small-step-for-l2-one-giant-leap-for-ethereum-bc9108047450\n\n- https://chainstack.com/arbitrum-nitro-an-overview/#3-nitro-vs-classic\n\n",
      "name": "References",
      "stepItems": [],
      "uuid": "d10846b3-3be8-43e0-9e3b-c8a48b29b98a"
    }
  ],
  "thumbnail": "https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/arbitrum_nitro_arbitrum_university_560/1699877538895_rectangle_95.png",
  "uuid": "arbitrum-nitro-arbitrum-university-560",
  "version": 1,
  "priority": 95
}