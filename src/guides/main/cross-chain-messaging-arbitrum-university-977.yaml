categories: []
content: Bridging Blockchains with Seamless Communication
created: '2023-11-13T18:37:55.147Z'
guideType: onboarding
key: cross-chain-messaging-arbitrum-university-977
name: Cross Chain Messaging
publishStatus: Live
steps:
  - content: >-
      ## What is Cross Chain Messaging?

      Cross-chain messaging is the process of transferring data, tokens, and
      other types of assets between different blockchain networks. Blockchains
      traditionally operate in silos, meaning they function independently and
      cannot natively share information or assets with one another. Cross-chain
      technology aims to bridge this gap, allowing for interoperability, or the
      ability for diverse blockchain networks to communicate and interact
      seamlessly.


      Cross-chain messaging works through smart contracts that facilitate the
      free flow of information between isolated blockchain networks. This
      creates a decentralized network where users can interact with dApps across
      different chains in a verifiable and trustless manner, supported by
      on-chain validators, without the need for manual navigation through
      bridges. This interconnectedness promises a streamlined and decentralized
      Web3 ecosystem, enhancing user experience and enabling developers to offer
      more integrated and efficient dApp services.


      ## Need for Cross Chain Messaging

      Cross-chain messaging is essential for addressing several needs in the
      cryptocurrency sector:


      1. **Asset Interoperability**: It allows for the seamless transfer of
      assets between different blockchains, helping to reduce the fragmentation
      of capital. By enabling this flow, smaller blockchains can access the
      liquidity and user base of larger ones, increasing overall capital
      efficiency and improving liquidity conditions.


      2. **Decentralization**: Cross-chain technology supports the decentralized
      movement of funds, reducing reliance on centralized entities or
      custodians. This trustless nature of technology is a core principle of
      blockchain interoperability, promoting a more decentralized financial
      ecosystem.


      3. **Minimizing Fragmentation and Improving Composability**: As the
      blockchain space grows, a smart contract's ability to interact natively is
      limited to its home network. Cross-chain messaging opens up the
      possibility for these contracts to interact beyond their native chains,
      thus reducing the issues of fragmented liquidity and improving the
      composability of applications across the broader blockchain landscape.


      4. **Efficient Resource Utilization**: Deploying applications on multiple
      chains consumes significant development resources. Cross-chain messaging
      aims to streamline this process, enabling applications to interact across
      chains without the need for separate deployments, which allows developers
      to focus on improving the core functionality of their applications. 
    name: Cross Chain Messaging
    stepItems: []
    uuid: 2b2cd485-6d77-4bb6-ab60-a13ab658feb0
  - content: ''
    name: Evaluation
    stepItems: []
    uuid: 0b537aa5-d7f1-41bf-88e1-f0b38af513dc
  - content: >-
      The Arbitrum protocol and its associated tools simplify the process for
      developers to create cross-chain applications, enabling them to
      efficiently send messages between Ethereum and an Arbitrum chain, as well
      as in the reverse direction from an Arbitrum chain back to Ethereum.


      ### Ethereum to Arbitrum Messaging 

      Contract calls from Ethereum's Layer 1 to Arbitrum's Layer 2 can be
      initiated using the `createRetryableTicket` method of the Inbox contract.
      When the transaction is executed on Layer 1, the corresponding action on
      Layer 2 is usually processed within a short time frame. Typically, the
      execution on Layer 2 completes successfully; however, in cases where it
      does not and a reversal occurs, it can be attempted again by invoking the
      `redeem` function of the ArbRetryableTx precompiled contract.


      To visualise the example, check out the tutorial at
      https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/greeter.


      ### Arbitrum to Ethereum Messaging 

      Contracts on Arbitrum's Layer 2 can also send messages to be executed on
      Ethereum's Layer 1. This is done by invoking the `sendTxToL1` function on
      the ArbSys precompiled contract. After a waiting period for confirmation,
      which typically lasts about one week, these messages can be processed. The
      necessary data for execution is obtained by calling the
      `constructOutboxProof` method of the NodeInterface contract. Following
      this, the messages are executed on Layer 1 through the Outbox contract's
      `executeTransaction` method.


      To better understand, check out the demo at
      https://github.com/OffchainLabs/arbitrum-tutorials/tree/master/packages/outbox-execute.
    name: Arbitrum's Cross Chain Messaging
    stepItems: []
    uuid: c6565013-2272-47a3-9ff0-d6aa141f938f
  - content: ''
    name: Evaluation
    stepItems: []
    uuid: 1682ade3-97a3-4d83-bdfb-e75758c2edf4
  - content: >+
      ## What are Retryable Tickets?

      Retryable tickets in the Arbitrum system are a specific mechanism designed
      for sending messages from Ethereum's Layer 1 (L1) to Arbitrum's Layer 2
      (L2). They allow for the initiation of L1 transactions that will trigger
      executions on L2. When you submit a retryable ticket, you pay a fixed fee
      based on the size of the transaction data at L1. This fee ensures that the
      message is transmitted to L2, where it will be executed separately from
      the L1 transaction and at a different time, making the process
      asynchronous.


      The key feature of retryable tickets is that they ensure atomicity across
      the L1 and L2 operations. Atomicity means that the operations are linked;
      if the initial transaction on L1 that requests the submission is
      successful and does not revert, there is a strong assurance that the
      associated message will be executed on L2 eventually. This creates a
      reliable link between the two layers, allowing developers and users to
      coordinate complex cross-chain interactions with confidence that the
      actions will be completed as intended.


      ## Lifecycle of Retryable Tickets 

      The lifecycle of retryable tickets consists of the following 3 stages:


      ### 1. Submission 

      A retryable ticket is created by calling the `createRetryableTicket`
      function in the inbox contract. If this call is successful, a ticket will
      definitely be issued. It requires the sender to allocate enough funds for
      both submission and an execution attempt, yet this does not ensure the
      ticket's automatic redemption will succeed. When the correct funds are
      submitted, a new ticket with a unique ID is created and added to retryable
      buffer. The sender's account is charged for funds (submissionCost +
      I2CallValue), which is then reserved in escrow to use when the ticket is
      activated. Ticket creation causes the `ArbRetryableTx` precompile to emit
      a `TicketCreated` event containing the `TicketID` on L2.

      - `l1CallValue (also referred to as deposit)`: Not a real function
      parameter, it is rather the callValue that is sent along with the
      transaction

      - `address to`: The destination L2 address

      - `uint256 l2CallValue`: The callvalue for retryable L2 message that is
      supplied within the deposit (l1CallValue)

      - `uint256 maxSubmissionCost`: The maximum amount of ETH to be paid for
      submitting the ticket. This amount is (1) supplied within the deposit
      (l1CallValue) to be later deducted from sender's L2 balance and is (2)
      directly proportional to the size of the retryable’s data and L1 basefee

      - `address excessFeeRefundAddress`: The L2 address to which the excess fee
      is credited (l1CallValue - (autoredeem ? ticket execution cost :
      submission cost) - l2CallValue)

      - `address callValueRefundAddress`: The L2 address to which the
      l2CallValue is credited if the ticket times out or gets cancelled (this is
      also called the `beneficiary`, who's got a critical permission to cancel
      the ticket)

      - `uint256 gasLimit`: Maximum amount of gas used to cover L2 execution of
      the ticket

      - `uint256 maxFeePerGas`: The gas price bid for L2 execution of the ticket
      that is supplied within the deposit (l1CallValue)

      - `bytes calldata data`: The calldata to the destination L2 address


      <div align="center">
        <img style="max-height:400px;margin-bottom:30px" src="https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/cross_chain_messaging_arbitrum_university_977/1699898912101_screenshot_2023-11-13%20at%2011.07.31%20pm.png"/>
      </div>


      ### 2. Automatic Redemption 

      Ticket submission on Layer 1 and execution on Layer 2 are separate events;
      successful submission doesn't ensure execution. For execution, the user
      must have enough funds to cover the transaction fee and the base fee on
      Layer 2. If these criteria are met, the ticket will automatically attempt
      to execute, with success or failure depending on the gas provided. If the
      ticket auto-redeems successfully, it carries out the transaction with the
      original details including the sender, destination, callvalue and calldata
      from the submission. Any excess submission fee is returned to the user on
      Layer 2. To improve the chances of successful auto-redeem, the Arbitrum
      SDK can be used to determine the correct gas parameters for Layer 1 to
      Layer 2 messages. If the ticket isn't redeemed at submission or the first
      redeem attempt fails (possibly due to a rise in the Layer 2 gas price),
      the submission fee is used to store the ticket in memory for a week. Under
      these circumstances, the ticket must be redeemed manually.


      <div align="center">
        <img style="max-height:400px;margin-bottom:30px" src="https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/cross_chain_messaging_arbitrum_university_977/1699899673388_screenshot_2023-11-13%20at%2011.20.35%20pm.png"/>
      </div>


      ### 3. Manual Redemption

      Anyone can try to manually redeem an unclaimed ticket by using the
      ArbRetryableTx's redeem function, which supplies the gas for the
      redemption without being restricted by the original gas limit. ArbOS will
      prioritize this redemption in its processing queue, ensuring it's executed
      in the same block as the calling transaction, with no risk of hitting the
      block's gas limit before execution. If the fixed period (one week) elapses
      without a successful redeem, the ticket expires and will be automatically
      discarded, unless some party has paid a fee to keep the ticket alive for
      another full period. A ticket can live indefinitely as long as it is
      renewed each time before it expires. Upon successful redemption, the
      designated recipient gets the escrowed funds, and any leftover gas goes
      back to the system's gas pools. If it fails, the funds return to escrow
      for another try. Fees are settled during the initial transaction, so no
      additional fees are incurred or refunded at this stage. It's also
      important to note that while a ticket redemption is in progress, any
      attempts to cancel or reschedule it will fail, ensuring the ticket doesn't
      change during this process. If a ticket with funds is ultimately not used
      (either cancelled or expired), the escrowed funds will be sent to a
      specified refund address from the original submission.


      <div align="center">
        <img style="max-height:400px;margin-bottom:30px" src="https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/cross_chain_messaging_arbitrum_university_977/1699900133766_screenshot_2023-11-13%20at%2011.28.17%20pm.png"/>
      </div>

    name: L1 to L2 Messaging
    stepItems: []
    uuid: 4c6d4203-d72d-45fc-bdbd-c0d8b9dc899d
  - content: ''
    name: Evaluation
    stepItems: []
    uuid: 45ccd21e-4685-41e2-b6f7-18d3c9f606fd
  - content: |-
      ## Receipt 


      ## Alternative "unsafe" Retryable Ticket Creation


      ## Eth deposits


      ## Transacting via the Delayed Inbox


      ## Address Aliasing
    name: Additional Concepts
    stepItems: []
    uuid: 47dca17b-42d8-43ff-a8ae-894f128e993e
  - content: ''
    name: Evaluation
    stepItems: []
    uuid: 895f2692-d815-4d2a-9fec-59ae56ce5179
  - content: >-
      Arbitrum's L2 to L1 communication system allows for messages to be sent
      from its second-layer solution back to the main Ethereum blockchain, which
      is the first layer (L1). This system is designed somewhat like a mirror
      image of the process that sends messages from L1 to L2, but with specific
      differences tailored for the reverse direction.


      ## Protocol Flow

      Every time a new set of transactions is processed on Arbitrum's L2, a
      snapshot of certain information is taken. This snapshot includes a
      cryptographic summary called a Merkle root that uniquely represents all
      the L2 to L1 messages sent up to that point. After this snapshot is
      captured in a proposed block, it goes through a waiting period—often about
      a week—before it's fully confirmed. This waiting period is crucial for
      ensuring the security and finality of the transactions.


      ## Client Flow 

      When a user on Arbitrum's Layer 2 (L2) wants to send a message to
      Ethereum's main layer (Layer 1 or L1), they start by calling the
      `sendTxToL1` method on the L2 ArbSys precompile contract. This message is
      bundled into an assertion, a group of transactions processed by Arbitrum,
      and is typically included within about an hour. The assertion then goes
      through a confirmation period of about a week for security verification.
      After confirmation, the user must obtain a Merkle proof, which is done by
      calling the `constructOutboxProof` function on Arbitrum's NodeInterface
      contract. With this proof, the user approaches the Outbox contract on L1
      and calls `executeTransaction`, providing the proof to execute their
      message on the Ethereum mainnet, completing the cross-layer communication
      process.
    name: L2 to L1 Messaging
    stepItems: []
    uuid: 9e939755-5c98-45a0-8335-cdd8adb16734
  - content: ''
    name: Evaluation
    stepItems: []
    uuid: a8ed5c86-cc78-469c-ab98-aac3701cf5d5
  - content: >-
      ## Important Design Features


      Protocol design details are crucial in ensuring the smooth and efficient
      functioning of a system. 


      #### Contant Overhead of Calls 

      In the case of the Outbox system, one important aspect of its design is
      the constant overhead of calls to confirmNode. This means that regardless
      of the number of outgoing messages or the gas cost of executing them on
      L1, the cost of confirming nodes remains constant. This design choice
      prevents the RBlock confirmation process from being disrupted or
      manipulated.


      #### Long Delay Period

      The week-long delay period before outgoing messages can be executed is an
      inherent characteristic of Arbitrum Rollup and similar Optimistic Rollup
      style L2 solutions. This delay is necessary to allow time for Arbitrum
      validators to detect and prove any faults that may occur. While the result
      of a transaction can be anticipated as soon as it is published on-chain,
      Ethereum itself requires this delay period to accept the result and ensure
      the integrity of the protocol.


      #### Virtual Contracts

      In the context of the system, the NodeInterface is referred to as a
      "virtual" contract. Its methods can be accessed through specific calls,
      but it does not actually exist on the blockchain like a regular contract.
      It functions similarly to a precompile, which is a built-in contract in
      Ethereum that cannot receive calls from other contracts. This clever
      design choice allows for the inclusion of Arbitrum-specific data without
      the need for implementing a custom RPC (Remote Procedure Call) mechanism.


      ## Difference between Outbox and Retryables


      #### Automatic Execution

      Unlike Retryables, which allow for automatic L2 execution by providing
      Ether, outgoing messages in the Outbox system do not have the capability
      for in-protocol automatic L1 execution. This is because Ethereum itself
      does not offer scheduled execution features. However, it is possible to
      build application-layer contracts that interact with the Outbox and
      provide similar functionality through an "execution market" approach. This
      would allow for outsourcing the final L1 execution step.


      #### Lifespan

      Another difference between outgoing messages and Retryables is their
      lifetime. Retryables have a limited lifespan and must be redeemed or have
      their lifetime extended before a certain deadline. On the other hand, L2
      to L1 messages in the Outbox system are stored in L1 state and persist
      permanently without any specific deadline for execution.
    name: Protocol Design Details
    stepItems: []
    uuid: 5b8bc743-4417-4f4c-b85d-1e2ef5174150
  - content: ''
    name: Evaluation
    stepItems: []
    uuid: dbaea1cf-22eb-4c4d-96b6-106ba0c7d26a
  - content: >+
      ## Step 1


      -
      https://www.techopedia.com/definition/cross-chain-in-blockchain#:~:text=XCM%20is%20a%20messaging%20format,chain%20and%20executed%20in%20another.

      - https://chain.link/education/cross-chain

    name: References
    stepItems: []
    uuid: c77989b0-22f7-4926-8e33-9b38540f66e8
thumbnail: >-
  https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/cross_chain_messaging_arbitrum_university_977/1699877869240_rectangle_101.png
uuid: cross-chain-messaging-arbitrum-university-977
version: 1
priority: 50
