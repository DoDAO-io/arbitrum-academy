categories: []
content: 'Understanding the differences between Arbitrum and Ethereum '
created: '2023-12-14T10:47:39.535Z'
guideType: onboarding
key: arbitrum-vs-ethereum-arbitrum-university-172
name: Arbitrum vs Ethereum
publishStatus: Live
steps:
  - content: >-
      Arbitrum and Ethereum are quite similar in many ways, but they also have
      some important differences. Here's a simpler explanation of what sets them
      apart:


      1. **Ease of Use for Developers**: If you already know how to build apps
      on Ethereum, you'll find Arbitrum very familiar. It's designed to be very
      much like Ethereum, so there's not much new stuff to learn.


      2. **How They Handle Time and Blocks**: The way Arbitrum deals with time
      and block numbers is different from Ethereum. This is important for
      developers because it affects how and when transactions happen.


      3. **Different Results with Some Commands**: Most of the commands (called
      RPC methods) you use in Arbitrum will work just like in Ethereum. However,
      some of them might give different results or extra information. It's good
      for developers to know this when they use these commands in Arbitrum.


      4. **Small Changes in Contract Deployment**: You can put your Solidity
      contracts onto Arbitrum just like you do in Ethereum, but there are a few
      small differences in how things work.


      5. **Fees**: Paying fees in Arbitrum is a bit like Ethereum. But, in
      Arbitrum, you also pay for something called calldata, which is the cost of
      connecting with the Ethereum chain. This two-part fee is a key difference.


      6. **Sending Messages Between Chains**: Arbitrum lets you send messages
      from Ethereum to Arbitrum and back. This is really useful for apps that
      need to work on both chains.


      7. **Extra Features for Contracts**: Arbitrum has all the features
      (precompiles) that Ethereum has, plus some extra ones just for Arbitrum.
      These extra features give developers more options for their smart
      contracts.


      8. **Special NodeInterface**: Arbitrum has a unique feature called
      NodeInterface. It's a special contract that you can use with commands, but
      it's not actually part of the blockchain like other contracts. It gives
      you some special abilities that regular contracts don't have.
    name: Arbitrum vs Ethereum
    stepItems: []
    uuid: 0d0e922e-6f2d-4e3a-97d4-afe4e527ee61
  - content: ''
    name: Evaluation
    stepItems: []
    uuid: 5068b4d1-722e-47fd-8e7e-0281507ef189
  - content: >-
      Arbitrum and Ethereum handle block numbers and time differently:


      ### Block Numbers

      - **Arbitrum Blocks vs. Ethereum Blocks**: In Arbitrum, each block gets
      its own L2 block number, which is different from Ethereum's block numbers.
      A single Ethereum block might contain several Arbitrum blocks, but each
      Arbitrum block is linked to just one Ethereum block.


      - **Block Numbers Inside Arbitrum Contracts**: If you check the block
      number inside an Arbitrum contract (like using `block.number` in
      Solidity), you'll get a number that's close to the Ethereum block number
      when the transaction was received. But it's not an exact match – it's more
      of an approximate.


      - **Arbitrum Block Number Creation**: Arbitrum creates blocks based on the
      number of transactions. If lots of people are using Arbitrum, you'll see
      blocks being made regularly. But if it's quieter, the blocks might come
      less frequently. These blocks start at 0 at Arbitrum's beginning and go up
      one by one.


      - **Accessing Block Numbers**: On the technical side, when you ask an
      Arbitrum node for transaction details, you'll get both the Arbitrum block
      number and the approximate Ethereum block number. And within an Arbitrum
      contract, you can use a special command (`ArbSys(100).arbBlockNumber()`)
      to find out the Arbitrum block number.


      ### Block Time

      - **Timing Not Tied to Ethereum**: In Arbitrum, the timing of each block
      isn't directly connected to Ethereum's block times. Instead, it's based on
      the sequencer's clock and updates with each new L2 block.


      - **Rules for Timestamps**: These timestamps have to follow two rules:
        1. Each new block's timestamp must be the same or later than the last block's timestamp.
        2. The timestamp should be within a certain range – no more than 24 hours behind the current time and not more than 1 hour ahead.

      - **Special Case for Transactions**: For certain transactions that come
      directly from Ethereum (bypassing the usual process), the block timestamp
      in Arbitrum will be either the time the transaction was added to Ethereum,
      or the timestamp of the last Arbitrum block, whichever is later.


      - **Adjustments by Sequencer**: The sequencer, which manages the timing,
      has some wiggle room to adjust timestamps. This is to prevent problems if
      it can't post batches to Ethereum on time. But there's a limit to how much
      it can adjust to keep things in order.


      ### Key Takeaways

      - Arbitrum uses its own system for block numbers and times, separate from
      Ethereum.

      - Block numbers in Arbitrum contracts are close to Ethereum's but not
      exact.

      - Arbitrum's block times are based on its own clock, not directly tied to
      Ethereum's.

      - There are specific rules and limits to how Arbitrum handles timestamps
      to keep everything running smoothly.
    name: Block Numbers and Time
    stepItems: []
    uuid: 6c3a5926-2a51-47bb-8993-7ee42a4026b2
  - content: ''
    name: Evaluation
    stepItems: []
    uuid: d7e1c842-3dd8-4431-84f7-756db0efcda9
  - content: |-
      The RPC methods in Arbitrum and Ethereum have some key differences:

      1. **Transactions**: 
         - Arbitrum adds new fields and uses some existing fields differently in methods like `eth_getTransactionByHash`.
         - It introduces additional transaction types (e.g., `ArbitrumDepositTxType`, `ArbitrumUnsignedTxType`, etc.) with custom type codes (100-106).

      2. **Transaction Fields**:
         - New fields in Arbitrum: `requestId` for L1 to L2 transactions.
         - Altered fields: The `from` field in L1 to L2 transactions shows the aliased version of L1's `msg.sender`.

      3. **Transaction Receipts**:
         - Additional fields in Arbitrum include `l1BlockNumber` and `gasUsedForL1`.

      4. **Blocks**:
         - In methods like `eth_getBlockByHash`, Arbitrum adds fields such as `l1BlockNumber`, `sendCount`, and `sendRoot`.
         - It alters fields like `extraData`, `mixHash`, `difficulty`, and `gasLimit` differently from Ethereum.

      5. **eth_syncing**:
         - Arbitrum provides more detailed information when syncing, with custom fields like `batchSeen`, `batchProcessed`, `messageOfProcessedBatch`, etc.

      6. **Understanding Messages, Batches, and Blocks**:
         - Nitro nodes in Arbitrum receive and process transactions differently, impacting the relationship between message numbers and block numbers.
    name: RPC Methods
    stepItems: []
    uuid: 052ae7a5-c972-4dd7-badb-fe51e0b8be9e
  - content: ''
    name: Evaluation
    stepItems: []
    uuid: 460179d1-32e7-48dd-9881-4fbb3bfc6a89
  - content: >-
      Arbitrum allows for seamless deployment of Solidity and Vyper smart
      contracts compatible with Ethereum, but certain properties and functions
      may yield different results compared to their Ethereum counterparts.


      1. In Arbitrum, the `blockhash(x)` function returns a pseudo-random hash
      within a specific range, but it should not be considered a secure source
      of randomness, as the hashes do not come from Ethereum's Layer 1 (L1).


      2. The `block.coinbase` function in Arbitrum differs in that it returns a
      designated internal address for messages posted by the sequencer, and for
      delayed messages, it returns the address of the poster. However, changes
      are expected in future updates.


      3. Arbitrum sets the `block.difficulty` and `block.prevrandao` properties
      to a constant value of 1, unlike Ethereum where these values can vary.


      4. The `block.number` function in Arbitrum gives an estimated L1 block
      number correlating with the transaction's reception, while the
      `msg.sender` behaves similarly to Ethereum for regular transactions but
      differs for transactions submitted via the delayed inbox.
    name: Solidity
    stepItems: []
    uuid: 5b4f4c0b-06f0-4c89-9e4d-6509347d0127
  - content: ''
    name: Evaluation
    stepItems: []
    uuid: 9459241f-1fd9-490d-83f8-fc2aeb7e8c30
thumbnail: >-
  https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/arbitrum_vs_ethereum_arbitrum_university_172/1699897539609_rectangle_105.png
uuid: arbitrum-vs-ethereum-arbitrum-university-172
version: 1
priority: 50
