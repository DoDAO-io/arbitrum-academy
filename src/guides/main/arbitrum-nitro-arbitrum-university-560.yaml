categories: []
content: A deeper look into Arbitrum Nitro
created: '2023-11-08T16:03:23.701Z'
guideType: onboarding
key: arbitrum-nitro-arbitrum-university-560
name: 'Arbitrum Nitro '
publishStatus: Live
steps:
  - content: >-
      ## What is Arbitrum Nitro?


      Arbitrum Nitro is a significant technical upgrade for Arbitrum, which is a
      Layer 2 scaling solution for Ethereum. It aims to lower transaction fees
      and increase the processing capacity of Ethereum by moving contract
      computation and storage from the primary chain. This upgrade, known as
      Nitro, is designed to be more compatible with the Ethereum Virtual Machine
      (EVM) and provides a better user experience with lower fees and faster
      transactions. With Nitro, Arbitrum aims to push the boundaries of
      security, efficiency, and scalability, offering a promising solution for
      the future of Ethereum. 


      It introduces advanced calldata compression, reducing transaction costs
      even further. Nitro enhances the performance of Layer 1 (L1) nodes, aligns
      EVM operation pricing with Ethereum, and introduces additional
      synchronization with Ethereum L1 blocks. As it seamlessly supports the
      Ethereum Virtual Machine (EVM), no hefty modifications are required. With
      Nitro, transactions on Arbitrum have become extremely efficient. 


      ## Innovative Features of Arbitrum Nitro


      #### WebAssembly Code


      Nitro introduces a new prover that uses WebAssembly (WASM) code to perform
      Arbitrum's interactive fraud proofs. This upgrade enhances the scalability
      and efficiency of the system, allowing for thousands of transactions to be
      processed per second. Despite being a separate blockchain, Arbitrum Nitro
      maintains the security and privacy features of Ethereum's Layer 1 (L1) and
      relays all transaction information to the main Ethereum chain.


      #### EVM Compatiblility


      Developers can easily integrate Arbitrum Nitro without making any
      modifications because it supports the EVM. This means that existing
      Ethereum contracts and transactions can run on Arbitrum without any
      changes. This distinguishes Arbitrum Nitro from other layer 2 solutions as
      each have their own VMs thereby requiring modifications for integration. 


      #### Deterministic Transactions


      To use Arbitrum Nitro, users need to submit their transactions to the
      chain's inbox. The chain will then execute the transaction and produce
      outputs, including a transaction receipt and any initiated withdrawals.
      The execution of transactions is deterministic, meaning that the result is
      known as soon as the transaction is placed in the inbox. Arbitrum ensures
      the correctness of the chain state and outputs, supports
      Ethereum-compatible contracts and transactions, and manages the transfer
      and management of ETH and tokens on the chain. 
    name: Introduction to Arbitrum Nitro
    stepItems: []
    uuid: 71f23120-3f81-446c-9d03-fe061903a797
  - content: ''
    name: Evaluation
    stepItems:
      - label: Full Name
        required: false
        type: PublicShortInput
        uuid: c3f60710-b204-4c63-bd7c-809389c6735f
      - answerKeys:
          - choice_1
          - choice_2
          - choice_3
        choices:
          - content: Choice 1
            key: choice_1
          - content: Choice 2
            key: choice_2
          - content: Choice 3
            key: choice_3
          - content: Choice 4
            key: choice_4
        content: Contents of the question
        type: MultipleChoice
        uuid: 4f6183f2-289d-45f2-bebd-8f1661846cf5
        explanation: Explanation of the question
    uuid: 40dd8254-e6e1-4dd7-9e68-34f14bf45792
  - content: >
      Here is the comparison between Arbitrum Nitro and Arbitrum Classic
      (original version of Arbitrum):


      | Feature                                  | Arbitrum
      Classic                                              | Arbitrum
      Nitro                                                  |

      |------------------------------------------|---------------------------------------------------------------|-----------------------------------------------------------------|

      | Goal                                     | Execution environment
      resembling EVM as second layer to Ethereum | Execution environment
      resembling EVM as second layer to Ethereum |

      | Virtual Machine Used                     | Arbitrum Virtual Machine
      (AVM)                                  | WebAssembly
      (Wasm)                                              |

      | Low-Level Instructions                   | Uses AVM for low-level
      instructions                             | Compiles Go code to WASM for
      low-level instructions             |

      | Architecture                             | Relies on AVM for execution
      environment                         | Direct usage of Geth's EVM
      implementation, enhancing efficiency |

      | Gas Fees and Ethereum Compatibility      | Higher fees compared to
      Nitro, due to less optimized execution environment | Lower fees and better
      Ethereum compatibility due to native execution of Go code |

      | Codebase Simplicity                      | More complex due to custom
      AVM, posing higher technical risks   | Simpler and more accessible
      codebase, reducing technical risks  |

      | Coding Languages                         | Solidity or
      Vyper                                                | Go (a more common
      language)                                     |

      | Code Conversion                          | EVM bytecode converted to AVM
      bytecode                           | Uses Wasm only when there's a
      dispute                           |

      | Transaction Management and Fraud Proofs  | AVM bytecode runs
      transactions and generates fraud proofs        | Checkpoints summarize
      transactions; Wasm used for disputes      |

      | Dispute Resolution                       | Validators inspect AVM
      bytecode in case of disputes              | Validators agree on block
      before examining Wasm details         |

      | Efficiency and Resource Management       | Less efficient, prepares for
      problems even if they do not occur  | More efficient, converts to Wasm
      only during disputes, saving time and resources |
    name: Nitro vs Classic
    stepItems: []
    uuid: 488abfeb-0e2c-472d-88cf-8fbc888963ee
  - content: ''
    name: Evaluation
    stepItems: []
    uuid: ca041520-b639-4eab-b2c7-37b09560b6ea
  - content: >+
      ## The Key Nitro Design Ideas


      Designed to enhance efficiency and streamline workflows, the Nitro design
      emerges as an evidence to innovation in the Ethereum ecosystem. It is
      based on four big idea:


      #### Sequencing and Deterministic Execution


      When a user sends a transaction on the Nitro chain, it is signed with
      their wallet and given to the Sequencer. The Sequencer orders transactions
      and publishes them, after which they're processed to update the Nitro
      chain state, producing Layer 2 blocks as needed. Invalid transactions are
      rejected to keep the sequence authentic. Since the process is
      deterministic, anyone with the transaction sequence can verify the state
      changes without a consensus mechanism.


      The Sequencer uses a real-time alert system for immediate soft finality
      and batches transactions on the Ethereum chain for hard finality. The
      latter involves compressing transactions using "brotli" and posting them
      to Ethereum, where their finalization ensures the sequence's immutability
      on Nitro.


      <div align="center">
        <img style="max-height:400px;margin-bottom:30px" src="https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/arbitrum_nitro_arbitrum_university_560/1699455146437_screenshot_2023-11-08%20at%207.19.13%20pm-photoroom.png-photoroom.png"/>
      </div>


      #### Based on Go-Ethereum


      Nitro's design is anchored by "geth at the core," using go-ethereum, the
      leading Ethereum node software, as the foundation and top layers of its
      "geth-sandwich" architecture, with the custom ArbOS layer in between. The
      base layer is the core of geth, modified slightly for Nitro's functions,
      while ArbOS adds Layer 2 capabilities like Sequencer data processing and
      cross-chain transactions. The top layer, also from geth, handles network
      interactions and node operations. The State Transition Function (STF)
      within this structure, including parts of geth and ArbOS, manages
      transactions and generates new blocks on Nitro.


      #### Separate Execution and Proving


      Nitro tackles the rollup system's challenge of efficiency versus
      verifiability by using the same codebase for both but compiling
      differently. Execution compiles to native code via the Go compiler, while
      verification compiles the State Transition Function (STF) into a
      WebAssembly variant, WAVM, optimized for proofs.


      Nitro adapts WebAssembly (Wasm) into WAVM for its specific needs,
      enhancing it for blockchain use. WAVM includes specialized instructions
      like "ReadPreImage" to enable state tree modifications through Merkle
      proofs, a technique derived from Arbitrum's "hash oracle trick," which
      necessitates participants keeping complete data structures for access.


      #### Optimistic Rollup


      Arbitrum, an optimistic rollup, records transaction inputs on the Ethereum
      blockchain, allowing anyone to reconstruct the state of its chain from
      this data. It's "optimistic" because it assumes transactions are valid by
      default; it publishes new blocks without immediate proof, relying on a
      challenge period for verification. If no challenges arise within roughly a
      week, the transaction is confirmed; if challenged, Arbitrum's dispute
      resolution protocol determines the truth, penalizing false claims with
      lost deposits.


      Disputes in Arbitrum are resolved using interactive fraud proofs, a method
      that minimizes work for the Ethereum main chain (Layer 1). When a dispute
      occurs, the parties engage in a protocol that incrementally narrows down
      the contested claim until it's just about a single execution step, which
      the Ethereum network then verifies. This interactive process offloads most
      of the dispute resolution work off-chain, making it more efficient and
      cost-effective compared to re-executing entire transactions on Ethereum.


      TO DO: ADD PROPER DIAGRAMS


      <div align="center">
        <img style="max-height:400px;margin-bottom:30px" src="https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/arbitrum_nitro_arbitrum_university_560/1699459277274_screenshot_2023-11-08_at_7.19.13_pm-removebg-preview_%281%29.png"/>
      </div>

    name: 'Arbitrum Nitro Design '
    stepItems: []
    uuid: fc866114-3380-41da-a037-351a9246246a
  - content: ''
    name: Evaluation
    stepItems: []
    uuid: e49c619f-5960-4060-9b89-cdd09521cf36
  - content: >+
      - https://docs.arbitrum.io/why-nitro


      -
      https://docs.arbitrum.io/inside-arbitrum-nitro/#:~:text=Nitro%20is%20a%20major%20upgrade,of%20data%20posted%20to%20L1


      -
      https://medium.com/offchainlabs/arbitrum-nitro-one-small-step-for-l2-one-giant-leap-for-ethereum-bc9108047450


      - https://chainstack.com/arbitrum-nitro-an-overview/#3-nitro-vs-classic

    name: References
    stepItems: []
    uuid: d10846b3-3be8-43e0-9e3b-c8a48b29b98a
thumbnail: >-
  https://d31h13bdjwgzxs.cloudfront.net/QmWy8EeMnxqx96VEPx2NBwzqtKxvMQqVVYvmPKgAYS2cUi
uuid: arbitrum-nitro-arbitrum-university-560
version: 1
priority: 50
